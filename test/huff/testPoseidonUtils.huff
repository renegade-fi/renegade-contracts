/// @title Test Poseidon Utils
/// @author @joeykraut
/// @notice Test the utils for the Poseidon2 permutation

#include "../../src/crypto/poseidon2/roundUtils.huff"

/// @dev Test the SBOX function applied to a single input
#define function testSboxSingle(uint256) nonpayable returns(uint256) 
/// @dev Test the ADD_RC function applied to a single input
#define function testAddRc(uint256) nonpayable returns(uint256) 

/// @dev The test round constant
#define constant TEST_RC = 0x1337

/// @dev Entrypoint to the poseidon test suite
#define macro MAIN() = takes(0) returns(0) {
    // Get the function selector
    0x0 calldataload 0xe0 shr // [SELECTOR]
    dup1 __FUNC_SIG(testSboxSingle)     eq testSboxSingle   jumpi
    dup1 __FUNC_SIG(testAddRc)          eq testAddRc        jumpi

    // Revert if the function selector is not valid
    0x1 0x0 mstore
    0x1 0x0 revert

    testSboxSingle:
        TEST_SBOX_SINGLE()
    testAddRc:
        TEST_ADD_RC()
}

/// @notice Test the sbox function applied to a single input
#define macro TEST_SBOX_SINGLE() = takes(0) returns(0) {
    // Get the input from calldata 
    PUSH_PRIME()
    0x04 calldataload

    // Call the sbox function
    SBOX()

    // Return the result
    RETURN_FIRST()
}

/// @notice Test the add round constant function applied to a single input
#define macro TEST_ADD_RC() = takes(0) returns(0) {
    // Get the input from calldata 
    PUSH_PRIME()
    0x04 calldataload

    // Call the add round constant function
    ADD_RC(TEST_RC)

    // Return the result
    RETURN_FIRST()
}

// --- Helpers --- //

/// @dev Return the first value on the stack
#define macro RETURN_FIRST() = returns(0) {
    0x00 mstore
    0x20 0x00 return
}
