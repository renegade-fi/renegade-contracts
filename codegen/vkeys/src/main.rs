//! Generate verification keys for all Renegade circuits, and write them into a solidity file as ABI-encoded constant bytes
#![allow(incomplete_features)]
#![feature(generic_const_exprs)]
mod vkeys_v1;
mod vkeys_v2;

use alloy_sol_types::SolValue;
use anyhow::{anyhow, Result};
use clap::{Args, Parser};
use reference_impl_common::abi_types::{ProofLinkingVK, VerificationKey};
use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

const CONTRACT_NAME: &str = "VerificationKeys";

/// A named verification key for a circuit
pub struct NamedVkey {
    pub name: String,
    pub vkey: VerificationKey,
}

/// A named linking verification key
pub struct NamedLinkingVkey {
    pub name: String,
    pub vkey: ProofLinkingVK,
}

/// Command line arguments for the vkeys-codegen binary
#[derive(Parser, Debug)]
#[clap(author, version, about)]
struct Cli {
    /// Path to output the generated Solidity file
    #[clap(short, long, default_value = "VerificationKeys.sol")]
    output: PathBuf,
    #[command(flatten)]
    args: VersionArgs,
}

#[derive(Args, Debug)]
#[group(required = true, multiple = false)]
struct VersionArgs {
    /// Use version 1 verification key generation
    #[clap(long)]
    v1: bool,
    /// Use version 2 verification key generation
    #[clap(long)]
    v2: bool,
}

#[derive(Debug, Clone, Copy)]
enum Version {
    V1,
    V2,
}

/// Generate the Solidity contract with verification keys
fn generate_solidity_contract(
    circuits: &[NamedVkey],
    linking_instances: &[NamedLinkingVkey],
) -> Result<String> {
    // Contract header
    let mut contract = String::new();
    contract.push_str("// SPDX-License-Identifier: MIT\n");
    contract.push_str("pragma solidity ^0.8.24;\n\n");
    contract.push_str(
        "// ⚠ ️WARNING: This file is auto-generated by `codegen/vkeys`. Do not edit directly.\n",
    );
    contract.push_str(&format!("library {CONTRACT_NAME} {{\n"));

    // Push all verification keys to the contract string
    for circuit in circuits {
        println!("Generating vkey for {}", circuit.name);
        let const_name = format!("{}_VKEY", circuit.name);
        let abi_bytes = circuit.vkey.abi_encode();
        add_constant(&mut contract, &const_name, &abi_bytes);
    }

    // Push all linking vkeys to the contract string
    for instance in linking_instances {
        println!("Generating vkey for {}", instance.name);
        let const_name = format!("{}_VKEY", instance.name);
        let abi_bytes = instance.vkey.abi_encode();
        add_constant(&mut contract, &const_name, &abi_bytes);
    }

    // Close contract
    contract.push_str("}\n");
    Ok(contract)
}

/// Add a constant to the contract in the form `bytes constant public {name} = {value};`
fn add_constant(contract: &mut String, name: &str, value: &[u8]) {
    let hex_value = hex::encode(value);
    contract.push_str(&format!(
        "\tbytes constant public {name} = hex\"{hex_value}\";\n",
    ));
}

fn main() -> Result<()> {
    // Parse command line arguments
    let cli = Cli::parse();
    let version = if cli.args.v1 {
        Version::V1
    } else {
        Version::V2
    };

    // Generate all vkeys
    let (circuits, linking_instances) = match version {
        Version::V1 => {
            println!("Generating v1 verification keys for all Renegade circuits");
            vkeys_v1::gen_all_vkeys()
        }
        Version::V2 => {
            println!("Generating v2 verification keys for all Renegade circuits");
            vkeys_v2::gen_all_vkeys()
        }
    };

    // Generate Solidity contract with all verification keys and write to file
    let contract = generate_solidity_contract(&circuits, &linking_instances)?;
    let mut file =
        File::create(&cli.output).map_err(|e| anyhow!("Failed to create output file: {}", e))?;
    file.write_all(contract.as_bytes())
        .map_err(|e| anyhow!("Failed to write to output file: {}", e))?;

    println!(
        "Successfully generated verification keys and wrote them to {}",
        cli.output.display()
    );
    Ok(())
}
