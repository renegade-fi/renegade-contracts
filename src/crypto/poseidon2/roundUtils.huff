/// Helpers for Poseidon2 round functions

/// @dev The scalar field modulus of BN254
#define constant PRIME = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001 

/// @dev Push the prime onto the stack
#define macro PUSH_PRIME() = {
    [PRIME]
}

/// @dev Add the round constant to the element on top of the stack
#define macro ADD_RC(RC) = takes(2) returns(1) {
    // Takes [x, PRIME]
    <RC> addmod       // [x + RC mod PRIME]
}

/// @dev Apply the sbox function to the element on top of the stack,
/// which is replaced by its fifth power mod p
/// I.e. transforms the stack [x, ...] -> [x^5 mod p, ...]
#define macro SBOX() = takes(2) returns(1) {
    // Takes [x, PRIME]
    // Prelude: setup primes on the stack in the order they'll be used
    dup2 dup1       // [PRIME, PRIME, x, PRIME]
    dup3            // [x, PRIME, PRIME, x, PRIME]
    dup1            // [x, x, PRIME, PRIME, x, PRIME]

    // Compute x^2 (mod p)
    mulmod          // [x^2 mod p, PRIME, x, PRIME]

    // Compute x^4 (mod p)
    dup1            // [x^2 mod p, x^2 mod p, PRIME, x, PRIME]
    mulmod          // [x^4 mod p, x, PRIME]
    
    // Compute x^5 (mod p)
    mulmod          // [x^5 mod p]
}

/// @dev Apply the internal MDS matrix to the sponge state
/// For t = 3, this is the matrix:
///     [2, 1, 1]
///     [1, 2, 1]
///     [1, 1, 3]
///
/// This can be done efficiently by adding the sum to each element as in the
/// external MDS case but adding an additional copy of the final state
/// element
/// @param Takes [state[0], state[1], state[2]]
/// @return [state'[0], state'[1], state'[2]]
#define macro INTERNAL_MDS() = takes(3) returns(7) {
    // Takes [state[0], state[1], state[2]]
    PUSH_PRIME()            // [PRIME, state[0], state[1], state[2]]
    dup4 dup4 dup4          // [state[0], state[1], state[2], PRIME, state[0], state[1], state[2]]

    // Compute the sum of the elements (mod p)
    PUSH_PRIME() swap2      // [state[1], state[0], PRIME, state[2], PRIME, state[0], state[1], state[2]]
    addmod                  // [state[0] + state[1] mod p, state[2], PRIME, state[0], state[1], state[2]]
    addmod                  // [sum, state[0], state[1], state[2]]

    // Add the sum to each element
    PUSH_PRIME() dup2       // [sum, PRIME, sum, state[0], state[1], state[2]] 
    dup6 addmod             // [state[2] + sum, sum, state[0], state[1], state[2]] 
    PUSH_PRIME() dup3       // [sum, PRIME, state[2] + sum, sum, state[0], state[1], state[2]]
    dup6 addmod             // [state[1] + sum, state[2] + sum, sum, state[0], state[1], state[2]]
    PUSH_PRIME() dup4       // [sum, PRIME, state[1] + sum, state[2] + sum, sum, state[0], state[1], state[2]]
    dup6 addmod             // [state[0] + sum, state[1] + sum, state[2] + sum, sum, state[0], state[1], state[2]]
}
