// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import { BN254 } from "solidity-bn254/BN254.sol";
import { PartialCommitment } from "darkpoolv2-types/PartialCommitment.sol";
import { IntentPublicShare, IntentPreMatchShare } from "darkpoolv2-types/Intent.sol";
import { PreMatchBalanceShare } from "darkpoolv2-types/Balance.sol";

// --- Validity Statements --- //
// Validity proofs verify that:
// 1. The owner of all new state elements has authorized their creation
// 2. Existing state elements are present in the Merkle tree
// 3. Nullifiers have been computed correctly for pre-update state elements
// 4. New shares have been allocated for updated elements
// The statements below represent different configurations of private vs public intents and balances,
// as well as first fill vs subsequent fills for private intents.

/// @notice A statement proving validity only for an intent, on its first fill
/// @dev This type doesn't need a nullifier, for example, but needs to emit the commitment
/// to the pre-updated intent so that we may check a signature.
struct IntentOnlyValidityStatementFirstFill {
    /// @dev The address of the intent owner
    /// @dev For private intents backed by public balances, we can
    /// leak this field on a match, as the obligation's settlement leaks
    /// it anyway.
    address intentOwner;
    /// @dev The commitment to the private shares of the intent
    BN254.ScalarField intentPrivateCommitment;
    /// @dev The recovery ID of the intent
    BN254.ScalarField recoveryId;
    /// @dev The encrypted intent; i.e. the public shares of the intent generated by the stream cipher.
    IntentPublicShare intentPublicShare;
}

/// @notice A statement for a proof of intent only state validity
/// @dev This is the same statement as above, but for a subsequent fill of a private intent.
/// As a result, it needs to nullify the previous intent commitment allocated into the darkpool.
struct IntentOnlyValidityStatement {
    /// @dev The address of the intent owner
    /// @dev For private intents backed by public balances, we can
    /// leak this field on a match, as the obligation's settlement leaks
    /// it anyway.
    address intentOwner;
    /// @dev The Merkle root to which the intent opens
    BN254.ScalarField merkleRoot;
    /// @dev A nullifier for the previous version of the intent
    BN254.ScalarField oldIntentNullifier;
    /// @dev The new public share of the amount field on the intent
    BN254.ScalarField newAmountShare;
    /// @dev A partial commitment to the intent
    /// @dev This is a commitment to all shares except the public share of the amount field which changes post-match.
    PartialCommitment newIntentPartialCommitment;
    /// @dev The recovery ID for the intent
    BN254.ScalarField recoveryId;
}

/// @notice A statement for a proof of intent and balance validity
/// @dev The statement type for `INTENT AND BALANCE FIRST FILL VALIDITY`
struct IntentAndBalanceValidityStatementFirstFill {
    /// @dev The Merkle root to which the balance opens
    BN254.ScalarField merkleRoot;
    /// @dev A commitment to the new one-time address and the original intent's commitment
    /// @dev A signature over this commitment by the previous one-time authorizing
    /// address is checked in-contract. This authorizes both the creation of the
    /// new intent by the owner and the rotation of the one-time authorizing address.
    BN254.ScalarField intentAndAuthorizingAddressCommitment;
    /// @dev The public shares of the intent minus the `amount_in` field
    /// @dev The public share of the `amount_in` field is leaked after it's been
    /// updated by the settlement circuit.
    IntentPreMatchShare intentPublicShare;
    /// @dev The partial commitment to the original intent
    /// @dev This commitment commits to all fields except the public share of the
    /// `amount_in` field. The smart contracts will resume the commitment by
    /// hashing in this share to the partial commitment.
    BN254.ScalarField intentPrivateShareCommitment;
    /// @dev The recovery identifier of the new intent
    BN254.ScalarField intentRecoveryId;
    /// @dev The partial commitment to the new balance
    PartialCommitment balancePartialCommitment;
    /// @dev The public share of the one-time authorizing address after it has been re-encrypted
    /// @dev Note that this value is only validated in-circuit and placed here to leak the value to indexers
    BN254.ScalarField newOneTimeAddressPublicShare;
    /// @dev The nullifier of the old balance
    BN254.ScalarField oldBalanceNullifier;
    /// @dev The recovery identifier of the new balance
    BN254.ScalarField balanceRecoveryId;
    /// @dev The owner-delegated authorizing signer of the balance
    /// @dev This one-time signer allows the balance to authorize a single intent for
    /// the first fill. This address may be rotated after it is used to prevent
    /// linking across transactions.
    address oneTimeAuthorizingAddress;
}

/// @notice A statement for a proof of intent and balance validity
/// @dev The statement type for `INTENT AND BALANCE VALIDITY`
struct IntentAndBalanceValidityStatement {
    /// @dev The Merkle root to which the old intent opens
    BN254.ScalarField intentMerkleRoot;
    /// @dev The nullifier of the old intent
    BN254.ScalarField oldIntentNullifier;
    /// @dev A partial commitment to the new intent
    /// @dev We omit the public share of the `amount_in` field here as this will
    /// change _during_ the match settlement. Instead, we commit to _all_
    /// private shares and _all_ public shares other than the `amount_in` field.
    PartialCommitment newIntentPartialCommitment;
    /// @dev The recovery identifier of the new intent
    BN254.ScalarField intentRecoveryId;
    /// @dev The Merkle root to which the old balance opens
    BN254.ScalarField balanceMerkleRoot;
    /// @dev The nullifier of the old balance
    BN254.ScalarField oldBalanceNullifier;
    /// @dev The partial commitment to the new balance
    PartialCommitment balancePartialCommitment;
    /// @dev The recovery identifier of the new balance
    BN254.ScalarField balanceRecoveryId;
}

// --- Output Balance Validity Statements --- //

/// @notice A statement for a proof of new output balance validity
/// @dev The statement type for `NEW OUTPUT BALANCE VALIDITY`
struct NewOutputBalanceValidityStatement {
    /// @dev The pre-match balance shares for the new balance
    PreMatchBalanceShare preMatchBalanceShares;
    /// @dev A partial commitment to the new output balance
    PartialCommitment newBalancePartialCommitment;
    /// @dev The recovery identifier of the new output balance
    BN254.ScalarField recoveryId;
}

/// @notice A statement for a proof of output balance validity
/// @dev The statement type for `OUTPUT BALANCE VALIDITY`
struct OutputBalanceValidityStatement {
    /// @dev The Merkle root to which the balance opens
    BN254.ScalarField merkleRoot;
    /// @dev The nullifier of the balance
    BN254.ScalarField oldBalanceNullifier;
    /// @dev The partial commitment to the balance
    PartialCommitment newPartialCommitment;
    /// @dev The recovery identifier of the balance
    BN254.ScalarField recoveryId;
}
